Made by Quincy Ryan 
Based on Butner's syllabus and study guides. 
Some examples generated by GPT, but generally written by Q, 
Structured at different pace because conceptual knowledge is assumed. 
Functions: Basics and 


**Guide Checklist**
- [ ] Intro
	- [ ] Why
	- [ ] History / comparison
	- [ ] Set up
	- [ ] General difference
		- [ ] Create C++ / C comparison
- [ ] Tools / Implementation
	- [x] S1: Basics: Vars and printing/getting
	- [x] S2: Strings
	- [ ] S3: Functions 
		- [ ] Basics
		- [ ] Advanced
	- [ ] S4: Importing
	- [x] S5: Logic: if, comparison, Lops, Switch
	- [ ] S6: Loops 
	- [ ] S7: Containers
	- [ ] S8: File reading / writing / web.  
	- [ ] S9: Exceptions / errors
	- [ ] S10: Classes / OOP
	- [ ] S11: Multi-programs
	- [ ] S12: algs / data structures
- [ ] Additional: Where to go next. 
- [ ] Example Mega program: 
	- [ ] C++ program that implements all features
	- [ ] Python program that implements all features 


### Why another python guide:
Other guides...
- Serve as a general intro to programming / CS problem solving: this is meant to build the vocabulary and filter out redundancy of someone who has programmed. 
- Do not give context meaning behind the switch. 
This guide is meant to be
- Aimed at People who already know C / C++ and want/need to learn python asap
- a reference without bloat.
- under 7 pages (no more than 10)
- a way to teach myself python
Guide will not cover
- Problem solving / Computational thought
- OOP concepts: If SAing w butner, you will be comfortable with OOP assuming you have / are taking 36b


# intro to python (by Q)

### **Python and C/C++:**
**C was developed** 
- Much more abstract and readable than alternatives
- Still pretty readable relatively speaking
- Not very "featured" and 
**C++ was developed...**
- More featured: 
	- OOP or "C with classes"
	- Try/throw errors
	- Build in data structures / containers
	- Huge innovation, More "there", less bottom up implementation
**Current (eternal) state of C langs...** 
- You have to manage memory
- Generally requires a wider knowledge of syntax/cs theory. 
- C++ suffers from "feature debt". C++ is often said to be *over featured* or bloated. There are so many cleaver trick and features that two people could be equipped with different "programming toolsets" to the point their code is almost incomprehensible to each other.
These are still great languages. They are complex but very popular. They are industry standard, and *Far Faster* than python. I personally love them. Programming feels wrong without a `;` to me. I'm working on it. 

**Python**:
Python was designed to make programming more accessible, easier, and faster to code. 

When should you use one over the other? 
Python
- Task automation (move files, rename files, scrape things from the internet)
- Prototyping a more complex program: 
- Literate programming (see more)
- Ai / ML : 
	- standard
	- Generally optimized: (see mojo)
- Data science
- **Because you are sick of the right angles and boxes that confine the world**, you want something simple and warm to get something meaningful done ASAP.

C / C++ 
- Things that need to run quickly (graphics, massive number crunching, systems)
- Things that need to run many many many times
- Thing that need to run on simple / old hardware
- **Because you crave structure / specificity in a vague, gooey world**. You don't mind taking some extra time to make what your doing really good, really fast, and maybe even poetic. 

## Set up
Python is an interpreted language, meaning it is run interactively form

IDEs: 
- IDLE: Default python IDE
- PyCharm: Jet-brains' more "built out" IDE
- VScode: if you use it already
- Jupyter Notebook: for documentation / words mixed with programming (see literate programming)

Python is an interpreted language, meaning *You do not need to compile anything*.  
Python sort of runs like a debugger already. Errors wont be found until they occur at runtime. (no compile time errors)

**INSERT CLI CODE**
```bash
```
Debugging:


## Implementation differences. 
Some starting differences.
If the languages can be broken down into *Grammar/syntax* (or in this case, ) and *vocabulary*, like a natural language
- style is syntax
- No `;`, (but sometimes `:`)
- Comments are `#`
- Nesting with tab chars (which is really 4 spaces)
- No main function
- Functions are a little different. 
- No `#include<stdlib>`, already included. 
- File is basically set up, and you don't need to add anything unless you want to add some additional features through modules. 
- All in all, Might seem totally different but they are more similar than not. 


**HERE C / C++ program**
vs
**Python Program**


# Tools / Implementation. 
## Section 1: Basics: vars and printing/getting
**In this section**: 
- Vars
	- Var assignment: 
	- Type hinting
	- Use variables in expressions 
- Cli getting / printing
- Type conversion
- Arithmetic operators. 

Python is **Dynamically typed**, so we do not need to specific the data type. 
We *can* **type hint** which makes our intentions clearer, and (may or may not) result in more optimized code. (See the "mojo" language). 

```python
x = 5 # var assignment
y = z = 10 # multi var assingment or
a, b = 0, 1 # multi var assingment 2

# Type hinting
var1: int = 1
str1: str = "Hello reader"

# Use variables in expression
result = x + y  # not really different from C
```

**CLI input/getting**
```python
print("hello world") # print to cli
user_input = input("Give me a number: ")
```

**Arithmetic operators**: all same, but we have floor div `//`
```python
result = 10 + 5  # Addition
result = 10 - 5  # Subtraction
result = 10 * 5  # Multiplication
result = 10 / 5  # Division
result = 10 // 3 # Floor Division
result = 10 % 3  # Modulus
```


**Type conversion.** 
```python
int_value = int("123")  # Convert string to integer
float_value = float("123.45")  # Convert string to float
str_value = str(123)  # Convert integer to string
bool_value = bool(1)  # Convert integer to boolean (True for 1)
```


## Section 2: Strings
**In this section**: 
- String operations
- String access
	- Characters
	- Substrings / slicing
- String class members / operations. 
### String Operations
**String Concatenation:**
```python
string1 = "Hello"
string2 = "World"
concatenated_string = string1 + " " + string2  # Results in 'Hello World'
multiplied_string = string1 * 3  # Results in 'HelloHelloHello'

# String formatting / f-string
name = "Alice"
age = 30
formatted_string = f"{name} is {age} years old."  # f-string for formatting

# string length:
length = len(string) # returns 5
```

Since you do not manage memory in python, you do not have to end terminate with `\n`
### Accessing Characters in a String
String access is similar, but now we are afforded Negative indexing. Since memory is managed, we can do negative indexing without finding the string length before hand. 

**Access Characters:**
```python
# Access first Cahr
first_char = string[0]  # Positive indexing
first_char_neg = string[-len(string)]  # Neg. Ind. = to string[0]

# Access Last char
last_char = string[-1]  # Negative indexing 
last_char_pos = string[len(string)-1]  # Positive indexing equivalent to string[4]

# Access Middle
middle_char = string[len(string)//2]  # For odd-length strings, gets the middle character
```
**Index Out of Bounds:** Throws an error at runtime (not compile, there is no compile. )

### String Slicing / `:` indexing / Substrings

Can define a range! no for loop
**Create a Copy of a String Using Slicing:**
```python
greeting = "Hello, World!"
copy_of_greeting = greeting[:]  # Copies the entire string
reversed_greeting = greeting[::-1]  # Reverses the string
first_five = greeting[:5]  # Returns 'Hello'
last_four = greeting[-4:]  # Returns 'rld!'
three_letters_from_index_7 = greeting[7:10]  # Extracts 'Wor' from 'Hello, World!'

out_of_bounds_slice = greeting[20:]  # Returns an empty string if index is out of bounds
```

### String Members / operations
```python
# String examples

# Returns Bool: evals whole string unless range is specified
ends_with = sample.endswith("World!") 
starts_with = sample.startswith("Hello") 
is_alpha = sample.isalpha() 
is_alnum = mixed.isalnum()  # Is alpha numeri
is_digit = digits.isdigit()  # evals all chars in str
is_lower = sample.islower()  # evals all chars
is_upper = sample.isupper()  # evals all cased chars
is_space = whitespace.isspace()  #evals

# returns String
lower_case = sample.lower()  # returns Lower case version of string
upper_case = sample.upper()  # returns Upper case version!'
stripped = "   Hello, World!   ".strip()  
	# Rm leading and trailing whitespace (+ other chars) 
	# -> "Hello, World!"
left_stripped = "   Hello, World!   ".lstrip()  
	# Remove l whitespace (+ other chars) 
	# -> "Hello, World!   "
right_stripped = "   Hello, World!   ".rstrip()  
	# Rm trailing whitespace (+ other chars) 
	# -> "   Hello, World!"
```


## Section 3: Functions
- Basic
	- Define functions
	- Call function. 
	- Parameter names, arguments: what matters when calling a function: "Do the names of parameters and arguments matter when calling a function? If not what does matter"
	- What is the difference between returning a value and printing a value? - not sure if valuable
- Advanced

**Advanced**
- function call
- Function Def
	- Overloading
		- Optional
		- Any number of positional
	- Functions with Functions as args. 

1. Be able to write functions that take optional arguments.
2. Be able to write functions that take any number of positional arguments
3. Be able to pass an iterable to a function that takes any number of positional arguments.
4. Be comfortable with functions that take other functions as arguments
    1. For example the functions sort, min, and max all take an optional parameter called key. Key is a function that is applied to each element in the iterable and the value returned from it is used in the actual comparisons. If we did max(-25, 5, 12, 8, key = abs) the value we would get back is -25 as has the largest absolute value of the numbers.




## Section 4: Importing Modules

Like `#include` or namespaces. 
Modules
Can define the way we use / call these functions

1. Be able to import a module
    1. Import the math module
    2. Import the random module
2. Be able to import a subcomponent of a module
    3. Import the log function from the math module
    4. Import the randint function from the random module

## Section 5: If, logic, comparison, switch
**In this section**:
- Boolean logic / comparisons 
- if, else, elif
	- implementation
- Switch statements

**Boolean logic**: `and` `or` `not` (No xor, nand, nor, etc. Can be implemented w functions)
**comparison**: `==` `!=` `<` `>` `<=` `>=`. 
Always good to use `(.)` to be safe. Must reiterate comparison when connected by logic like in C/C++. 

**If trees**:
- Conditions are not in `(.)`, end of condition `:`
- Scope is `    ` (4 spaces / tab) 
- `if`
- `elif` instead of `else if` in c
- `else:` doesn't require condition (like c and all others)

```python
def classify_grade(score):
    if score >= 90: # nesting
	    if score >= 96: 
		    return "A+"
		elif (score < 96 or score > 93): # multiple conditions
			return "A"
		else: 
			return "A-"
        return "A"
    elif score >= 80:
	    return "B"
    else: 
	    return "C or below" # dont @ me I'm lazy
    

```

Bonus: **Switch statements**: 
replaced by `match` + `case` keywords in python 3.10 and above
```python
match grade: 
	case "passing": 
		print("good job!")
	case "failed":
		print("Summer classes")
	case _: # default statment
		print("Don't know yet")
```


## Section 6: Loops

In this section: 
- Loop fundamentals
	- For loops
	- While loops
	- Nesting loops / Scope
- Loop tools
	- Enumeration
	- Zip
	- Break
	- Continue


## Section 7: Containers
In this section
- containers
	- Lists 
	- Tuples
	- Dictionaries
- Use for each
	- Getting
	- Setting
	- Looping / iteration. 

## Section 8: files
In this:
- getting from files
- Writing to files
- Web scraping? 

## Section 9: Exceptions / errors 

## Section 10: Classes / OOP

## Section 11: Multi file programs

## Section 12: Algs / data structures. 

# Additional / where to go next

For UI
For data science
For ML / neural networks
For games


From GPT 
1. **Debugging Techniques**
    - Understanding Python's error messages.
    - Using debugging tools like `pdb` (Python Debugger).
2. **Testing**
    
    - Writing unit tests using `unittest` or `pytest`.
    - Integration of tests into a development workflow.
3. **Virtual Environments**
    
    - Managing project dependencies using `venv` or `conda`.
    - Best practices for isolating project setups.
4. **Package Management**
    
    - Using `pip` for installing and managing packages.
    - Introduction to `pipenv` for managing project setups and dependencies.
5. **Data Handling**
    
    - Introduction to `pandas` for data manipulation.
    - Using `numpy` for numerical data.
6. **Concurrency and Parallelism**
    
    - Understanding `threading` and `multiprocessing`.
    - Using `asyncio` for asynchronous programming.
7. **Decorators and Generators**
    
    - Deep dive into advanced Python functions like decorators and generators.
8. **Graphical User Interfaces (GUI)**
    
    - Basics of creating applications with `tkinter` or `PyQt`.
9. **Web Development**
    
    - Introduction to web frameworks like Flask or Django.
10. **Best Practices**
    
    - Writing clean and maintainable Python code.
    - Understanding Pythonic principles.

